#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include "shader.h"
#include <E:/Downloads/lib/glut-3.7.6-bin/glut-3.7.6-bin/include/GL/glut.h>
#include "project4.h"

using namespace std;

static ObjReader objReader;

int nVerts;
float *vertices;
float *normals;
float *texcoords;
int nIndices;
int *indices;

static Camera camera;
static Cube all;			// Final matrix
static Cube cube1;			// Object matrix
static Cube cube2;			// Object matrix
static Cube light0;			// Light_0 matrix
static Cube light1;			// Light_1 matrix
static Cube base;			// Initial matrix before mouse event
static Cube temp;			// Evanescent matrix during mouse event
static Cube world;			// Accumulation matrix for base and temp
static Cube base_light0;
static Cube temp_light0;
static Cube world_light0;
static Cube base_light1;
static Cube temp_light1;
static Cube world_light1;

static Cube dragon;
static bool sphere = true;

bool light0Toggle = false;
bool light1Toggle = false;
bool lightShaderToggle = false;

int shader_state = -1;

char light0_vert[] = "light0_shading.vert";
char light0_frag[] = "light0_shading.frag";
char light1_vert[] = "light1_shading.vert";
char light1_frag[] = "light1_shading.frag";
char lightX_vert[] = "lightX_shading.vert";
char lightX_frag[] = "lightX_shading.frag";

Shader * shader0;
Shader * shader1;
Shader * shaderX;

float prevX, prevY, prevZ;
float xf, yf, zf;
bool pressedLeft, pressedMiddle, pressedRight;

float theta, axis;

GLfloat mat_diffuse[] = {0.5,0.5,0.5,1.0};
GLfloat mat_specular[]  = {1.0,1.0,1.0,1.0};
GLfloat mat_shininess[] = {25.0};

GLfloat light0_diffuse[] = { 1.0, 0.0, 0.0, 1.0 };
GLfloat light0_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light0_shininess[] = {50.0};
GLfloat light0_position[] = {-1.5,0.0,2.0,1.0};

GLfloat light1_diffuse[] = { 0.0, 1.0, 0.0, 1.0 };
GLfloat light1_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light1_direction[] = { 0.0, 0.0, -1.0 };
GLfloat light1_shininess[] = {50.0};
GLfloat light1_position[] = {-1.5,0.0,2.0,1.0};

GLfloat zero[] = {0.0,0.0,0.0,0.0};

int window::width  = 512;   // set window width in pixels here
int window::height = 512;   // set window height in pixels here

Group * g_world;
Matrix4 m_id = Matrix4();

double r_torso = 0.0;
double r_head = 0.0;
double r_shoulder_left = 0.0;
double r_shoulder_right = 0.0;
double r_leg_left = 0.0;
double r_leg_right = 0.0;
double r_arm_left = 0.0;
double r_arm_right = 0.0;
double r_foot_left = 0.0;
double r_foot_right = 0.0;

bool b_torso = true;
bool b_head_forward = true;
bool b_shoulder_left_forward = true;
bool b_shoulder_right_forward = false;
bool b_leg_left_forward = true;
bool b_leg_right_forward = false;
bool b_arm_left_forward = true;
bool b_arm_right_forward = false;
bool b_foot_left_forward = true;
bool b_foot_right_forward = false;

bool debug = true;
bool animate = true;
bool culling = true;

int army_size = 20;

/*GLdouble vf_left = -10.0;
GLdouble vf_right = 10.0;
GLdouble vf_bottom = -10.0;
GLdouble vf_top = 10.0;
GLdouble vf_near = 10.0;
GLdouble vf_far = 1000.0;*/
Vector3 p = Vector3(0,0,80);
Vector3 d = Vector3(0,0,0);
Vector3 up = Vector3(0,1,0);
GLdouble fovy = 45.0;
GLdouble aspect = float(window::width)/float(window::height);
GLdouble zNear = 1.0;
GLdouble zFar = 1000.0;
GLdouble vf_hnear;
GLdouble vf_wnear;
GLdouble vf_hfar;
GLdouble vf_wfar;
float frustum[6][4];
Vector4 frustum_points[8];

//  Pointer to a font style..
//  Fonts supported by GLUT are: GLUT_BITMAP_8_BY_13, 
//  GLUT_BITMAP_9_BY_15, GLUT_BITMAP_TIMES_ROMAN_10, 
//  GLUT_BITMAP_TIMES_ROMAN_24, GLUT_BITMAP_HELVETICA_10,
//  GLUT_BITMAP_HELVETICA_12, and GLUT_BITMAP_HELVETICA_18.
GLvoid *font_style = GLUT_BITMAP_8_BY_13;

//  printf prints to file. printw prints to window
void printw (float x, float y, float z, char* format, ...);

//  The number of frames
int frameCount = 0;

//  Number of frames per second
float fps = 0;

//  currentTime - previousTime is the time elapsed
//  between every call of the Idle function
int currentTime = 0, previousTime = 0;

// Methods
void animateObject();
void drawObject();
void calculateFPS();
void drawFPS();

Cube::Cube()
{
}

Matrix4& Cube::getMatrix()
{
	return matrix;
}

void Cube::drawPlane()
{
	glBegin(GL_QUADS);
	glNormal3f(0.0, -1.0, 0.0);
	glVertex3f(-10.0, 0.0, -10.0);
	glVertex3f( 10.0, 0.0, -10.0);
	glVertex3f( 10.0, 0.0,  10.0);
	glVertex3f(-10.0, 0.0,  10.0);
	glEnd();
}

void Cube::drawObj()
{
	int i;
	glBegin(GL_TRIANGLES);
	for (i=0; i<nIndices; i+=3)
	{
		srand(i);
		double r = rand() % 100 / 100.0;
		double b = rand() % 100 / 100.0;
		double g = rand() % 100 / 100.0;
		glVertex3f(vertices[indices[i]*3],vertices[indices[i]*3+1],vertices[indices[i]*3+2]);
		glVertex3f(vertices[indices[i+1]*3],vertices[indices[i+1]*3+1],vertices[indices[i+1]*3+2]);
		glVertex3f(vertices[indices[i+2]*3],vertices[indices[i+2]*3+1],vertices[indices[i+2]*3+2]);

		glNormal3f(normals[indices[i]*3],normals[indices[i]*3+1],normals[indices[i]*3+2]);
		glNormal3f(normals[indices[i+1]*3],normals[indices[i+1]*3+1],normals[indices[i+1]*3+2]);
		glNormal3f(normals[indices[i+2]*3],normals[indices[i+2]*3+1],normals[indices[i+2]*3+2]);
	}
	glEnd();
}

//-------------------------------------------------------------------------
//  Draw FPS
//-------------------------------------------------------------------------
void drawFPS()
{
    //  Load the identity matrix so that FPS string being drawn
    //  won't get animates
	glLoadIdentity ();
	glColor3d(1.0,1.0,1.0);
	//  Print the FPS to the window
	printw (-18, -18, 0, "FPS: %4.2f", fps);
}

//-------------------------------------------------------------------------
// Calculates the frames per second
//-------------------------------------------------------------------------
void calculateFPS()
{
    //  Increase frame count
    frameCount++;

    //  Get the number of milliseconds since glutInit called 
    //  (or first call to glutGet(GLUT ELAPSED TIME)).
    currentTime = glutGet(GLUT_ELAPSED_TIME);

    //  Calculate time passed
    int timeInterval = currentTime - previousTime;

    if(timeInterval > 1000)
    {
        //  calculate the number of frames per second
        fps = frameCount / (timeInterval / 1000.0f);

        //  Set time
        previousTime = currentTime;

        //  Reset frame count
        frameCount = 0;
    }
}

//-------------------------------------------------------------------------
//  Draws a string at the specified coordinates.
//-------------------------------------------------------------------------
void printw (float x, float y, float z, char* format, ...)
{
	va_list args;	//  Variable argument list
	int len;		//	String length
	int i;			//  Iterator
	char * text;	//	Text

	//  Initialize a variable argument list
	va_start(args, format);

	//  Return the number of characters in the string referenced the list of arguments.
	//  _vscprintf doesn't count terminating '\0' (that's why +1)
	len = _vscprintf(format, args) + 1; 

	//  Allocate memory for a string of the specified size
	text = (char *)malloc(len * sizeof(char));

	//  Write formatted output using a pointer to the list of arguments
	vsprintf_s(text, len, format, args);

	//  End using variable argument list 
	va_end(args);

	//  Specify the raster position for pixel operations.
	glRasterPos3f (x, y, z);

	//  Draw the characters one by one
    for (i = 0; text[i] != '\0'; i++)
        glutBitmapCharacter(font_style, text[i]);

	//  Free the allocated memory for the string
	free(text);
}

void drawFrustum()
{
	glLineWidth(2);
	glBegin(GL_LINES);
	glColor3d(1.0,0.0,0.0);
	/*glVertex4f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2),frustum_points[NTL].get(3));
	glVertex4f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2),frustum_points[NBL].get(3));
	glVertex4f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2),frustum_points[NBL].get(3));
	glVertex4f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2),frustum_points[NBR].get(3));
	glVertex4f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2),frustum_points[NBR].get(3));
	glVertex4f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[NTR].get(2),frustum_points[NTR].get(3));
	glVertex4f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[NTR].get(2),frustum_points[NTR].get(3));
	glVertex4f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2),frustum_points[NTL].get(3));
	glVertex4f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2),frustum_points[NTL].get(3));
	glVertex4f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2),frustum_points[FTL].get(3));
	glVertex4f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2),frustum_points[FTL].get(3));
	glVertex4f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2),frustum_points[FTR].get(3));
	glVertex4f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2),frustum_points[FTR].get(3));
	glVertex4f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[FTR].get(2),frustum_points[NTR].get(3));
	
	glVertex4f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2),frustum_points[NBR].get(3));
	glVertex4f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2),frustum_points[FBR].get(3));
	glVertex4f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2),frustum_points[FBR].get(3));
	glVertex4f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2),frustum_points[FTR].get(3));

	glVertex4f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2),frustum_points[FBR].get(3));
	glVertex4f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2),frustum_points[FBL].get(3));
	glVertex4f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2),frustum_points[FBL].get(3));
	glVertex4f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2),frustum_points[FTL].get(3));

	glVertex4f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2),frustum_points[FBL].get(3));
	glVertex4f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2),frustum_points[NBL].get(3));*/

	glVertex3f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2));//,frustum_points[NTL].get(3));
	glVertex3f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2));//,frustum_points[NBL].get(3));
	glVertex3f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2));//,frustum_points[NBL].get(3));
	glVertex3f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2));//,frustum_points[NBR].get(3));
	glVertex3f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2));//,frustum_points[NBR].get(3));
	glVertex3f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[NTR].get(2));//,frustum_points[NTR].get(3));
	glVertex3f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[NTR].get(2));//,frustum_points[NTR].get(3));
	glVertex3f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2));//,frustum_points[NTL].get(3));
	glVertex3f(frustum_points[NTL].get(0),frustum_points[NTL].get(1),frustum_points[NTL].get(2));//,frustum_points[NTL].get(3));
	glVertex3f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2));//,frustum_points[FTL].get(3));
	glVertex3f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2));//,frustum_points[FTL].get(3));
	glVertex3f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2));//,frustum_points[FTR].get(3));
	glVertex3f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2));//,frustum_points[FTR].get(3));
	glVertex3f(frustum_points[NTR].get(0),frustum_points[NTR].get(1),frustum_points[FTR].get(2));//,frustum_points[NTR].get(3));
	
	glVertex3f(frustum_points[NBR].get(0),frustum_points[NBR].get(1),frustum_points[NBR].get(2));//,frustum_points[NBR].get(3));
	glVertex3f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2));//,frustum_points[FBR].get(3));
	glVertex3f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2));//,frustum_points[FBR].get(3));
	glVertex3f(frustum_points[FTR].get(0),frustum_points[FTR].get(1),frustum_points[FTR].get(2));//,frustum_points[FTR].get(3));

	glVertex3f(frustum_points[FBR].get(0),frustum_points[FBR].get(1),frustum_points[FBR].get(2));//,frustum_points[FBR].get(3));
	glVertex3f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2));//,frustum_points[FBL].get(3));
	glVertex3f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2));//,frustum_points[FBL].get(3));
	glVertex3f(frustum_points[FTL].get(0),frustum_points[FTL].get(1),frustum_points[FTL].get(2));//,frustum_points[FTL].get(3));

	glVertex3f(frustum_points[FBL].get(0),frustum_points[FBL].get(1),frustum_points[FBL].get(2));//,frustum_points[FBL].get(3));
	glVertex3f(frustum_points[NBL].get(0),frustum_points[NBL].get(1),frustum_points[NBL].get(2));//,frustum_points[NBL].get(3));

	
	/*glVertex4f(frustum_points[0].get(0),frustum_points[0].get(1),frustum_points[0].get(2),frustum_points[0].get(3));
	glVertex4f(frustum_points[1].get(0),frustum_points[1].get(1),frustum_points[1].get(2),frustum_points[1].get(3));
	glVertex4f(frustum_points[2].get(0),frustum_points[2].get(1),frustum_points[1].get(2),frustum_points[2].get(3));*/
	glEnd();
}

Group* createRobot()
{
	Geode* mesh_torso = new Sphere(TORSO);
	Geode* mesh_head = new Sphere(HEAD);
	Geode* mesh_shoulder_left = new Sphere(SHOULDER);
	Geode* mesh_shoulder_right = new Sphere(SHOULDER);
	Geode* mesh_leg_left = new Sphere(LEG);
	Geode* mesh_leg_right = new Sphere(LEG);
	Geode* mesh_arm_left = new Sphere(ARM);
	Geode* mesh_arm_right = new Sphere(ARM);
	Geode* mesh_foot_left = new Sphere(FOOT);
	Geode* mesh_foot_right = new Sphere(FOOT);

	Matrix4 m_robot = Matrix4();
	Matrix4 m_torso = Matrix4();
	Matrix4 m_head = Matrix4();
	Matrix4 m_shoulder_left = Matrix4();
	Matrix4 m_shoulder_right = Matrix4();
	Matrix4 m_leg_left = Matrix4();
	Matrix4 m_leg_right = Matrix4();
	Matrix4 m_arm_left = Matrix4();
	Matrix4 m_arm_right = Matrix4();
	Matrix4 m_foot_left = Matrix4();
	Matrix4 m_foot_right = Matrix4();
	
	m_robot.identity();
	m_torso.identity();
	m_head.identity();
	m_shoulder_left.identity();
	m_shoulder_right.identity();
	m_leg_left.identity();
	m_leg_right.identity();
	m_arm_left.identity();
	m_arm_right.identity();
	m_foot_left.identity();
	m_foot_right.identity();
	
	m_robot.setMatrix(*m_robot.translate(0,0,-15));
	m_head.setMatrix(*m_head.rotateY(-90*PI/180));
	m_head.setMatrix(*m_head.translate(0,1.5,0));
	m_shoulder_left.setMatrix(*m_shoulder_left.rotateY(-90*PI/180));
	m_shoulder_left.setMatrix(*m_shoulder_left.translate(-.5,.2,0));
	m_shoulder_right.setMatrix(*m_shoulder_right.rotateY(90*PI/180));
	m_shoulder_right.setMatrix(*m_shoulder_right.translate(.5,.2,0));
	m_leg_left.setMatrix(*m_leg_left.rotateX(90*PI/180));
	m_leg_left.setMatrix(*m_leg_left.translate(-.5,-0.5,0));
	m_leg_right.setMatrix(*m_leg_right.rotateX(90*PI/180));
	m_leg_right.setMatrix(*m_leg_right.translate(.5,-0.5,0));
	m_arm_left.setMatrix(*m_arm_left.rotateX(180*PI/180));
	m_arm_left.setMatrix(*m_arm_left.rotateY(90*PI/180));
	m_arm_left.setMatrix(*m_arm_left.translate(0,0,1.0));
	m_arm_right.setMatrix(*m_arm_right.rotateX(180*PI/180));
	m_arm_right.setMatrix(*m_arm_right.rotateY(-90*PI/180));
	m_arm_right.setMatrix(*m_arm_right.translate(0,0,1.0));
	m_foot_left.setMatrix(*m_foot_left.translate(0,0,1.0));
	m_foot_right.setMatrix(*m_foot_right.translate(0,0,1.0));

	Group* g_robot = new MatrixTransform(id_world, m_robot);
	Group* g_torso = new MatrixTransform(id_torso, m_torso);
	Group* g_head = new MatrixTransform(id_head, m_head);
	Group* g_shoulder_left = new MatrixTransform(id_shoulder_left, m_shoulder_left);
	Group* g_shoulder_right = new MatrixTransform(id_shoulder_right, m_shoulder_right);
	Group* g_leg_left = new MatrixTransform(id_leg_left, m_leg_left);
	Group* g_leg_right = new MatrixTransform(id_leg_right, m_leg_right);
	Group* g_arm_left = new MatrixTransform(id_arm_left, m_arm_left);
	Group* g_arm_right = new MatrixTransform(id_arm_right, m_arm_right);
	Group* g_foot_left = new MatrixTransform(id_foot_left, m_foot_left);
	Group* g_foot_right = new MatrixTransform(id_foot_right, m_foot_right);
	
	g_robot->addNode(g_torso);
	g_torso->addNode(mesh_torso);
	g_torso->addNode(g_head);
	g_torso->addNode(g_shoulder_left);
	g_torso->addNode(g_shoulder_right);
	g_torso->addNode(g_leg_left);
	g_torso->addNode(g_leg_right);
	g_head->addNode(mesh_head);
	g_shoulder_left->addNode(mesh_shoulder_left);
	g_shoulder_left->addNode(g_arm_left);
	g_shoulder_right->addNode(mesh_shoulder_right);
	g_shoulder_right->addNode(g_arm_right);
	g_leg_left->addNode(mesh_leg_left);
	g_leg_left->addNode(g_foot_left);
	g_leg_right->addNode(mesh_leg_right);
	g_leg_right->addNode(g_foot_right);
	g_arm_left->addNode(mesh_arm_left);
	g_arm_right->addNode(mesh_arm_right);
	g_foot_left->addNode(mesh_foot_left);
	g_foot_right->addNode(mesh_foot_right);
	
	return g_robot;
}

void createWorld()
{
	Matrix4 m_world = Matrix4();
	m_world.identity();
	//m_world.setMatrix(*m_world.rotateY(45*PI/180));
	//m_world.setMatrix(*m_world.rotateX(45*PI/180));
	//m_world.setMatrix(*m_world.translate(2,-10,-20));
	g_world = new MatrixTransform(id_world, m_world);
	/*Group* g_robot1 = createRobot();
	Group* g_robot2 = createRobot();
	Matrix4 m_robot1 = Matrix4();
	Matrix4 m_robot2 = Matrix4();
	m_robot1.identity();
	m_robot2.identity();
	m_robot1.setMatrix(*m_robot1.translate(2.0,0,0));
	m_robot2.setMatrix(*m_robot2.translate(-2.0,0,0));
	char id_robot1[] = "id_robot1";
	char id_robot2[] = "id_robot2";
	Group* g_robot1_mt = new MatrixTransform(id_robot1, m_robot1);
	Group* g_robot2_mt = new MatrixTransform(id_robot2, m_robot2);
	g_world->addNode(g_robot1_mt);
	g_world->addNode(g_robot2_mt);
	g_robot1_mt->addNode(g_robot1);
	g_robot2_mt->addNode(g_robot2);*/
	int i,j;
	int counter = 1;
	for (i=-army_size; i<=army_size; i+=5)
	{
		for (j=-army_size; j<=army_size; j+=5)
		{
			Group* g_robot = createRobot();
			Matrix4 m_robot = Matrix4();
			m_robot.identity();
			m_robot.setMatrix(*m_robot.translate(i,0,j));
			char id_robot[] = "id_robot";
			Group* g_robot_mt = new MatrixTransform(id_robot, m_robot);
			g_world->addNode(g_robot_mt);
			g_robot_mt->addNode(g_robot);
			counter+=1;
		}
	}
}

float findZ(float x, float y)
{
	float z = 1 - x*x - y*y;

	if (z < 0)
	{
		z = 0;
	}
	else
	{
		z = sqrt(z);
	}
	return z;
}

float getTheta(Vector3 v, Vector3 w)
{
	return acos(v.dot(w) / (v.magnitude() * w.magnitude()));
}

void processMouse(int button, int state, int x, int y)
{
	if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
	{
		xf = (float)x/((float)window::width/2.0) - 1;
		yf = 1 - (float)y/((float)window::height/2.0);
		pressedLeft = true;
		prevX = xf;
		prevY = yf;
		prevZ = findZ(prevX,prevY);
		base.getMatrix().setMatrix(world.getMatrix());
		base_light0.getMatrix().setMatrix(world_light0.getMatrix());
		base_light1.getMatrix().setMatrix(world_light1.getMatrix());
	}
	else if (button == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
	{
		xf = (float)x/((float)window::width/2.0) - 1;
		yf = 1 - (float)y/((float)window::height/2.0);
		pressedMiddle = true;
		prevX = xf;
		prevY = yf;
		prevZ = findZ(prevX,prevY);
		base.getMatrix().setMatrix(world.getMatrix());
		base_light0.getMatrix().setMatrix(world_light0.getMatrix());
		base_light1.getMatrix().setMatrix(world_light1.getMatrix());
	}
	else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
	{
		xf = (float)x/((float)window::width/2.0) - 1;
		yf = 1 - (float)y/((float)window::height/2.0);
		pressedRight = true;
		prevX = xf;
		prevY = yf;
		prevZ = findZ(prevX,prevY);
		base.getMatrix().setMatrix(world.getMatrix());
		base_light0.getMatrix().setMatrix(world_light0.getMatrix());
		base_light1.getMatrix().setMatrix(world_light1.getMatrix());
	}
	else
	{
		base.getMatrix().setMatrix(world.getMatrix());
		base_light0.getMatrix().setMatrix(world_light0.getMatrix());
		base_light1.getMatrix().setMatrix(world_light1.getMatrix());
		temp.getMatrix().identity();
		temp_light0.getMatrix().identity();
		temp_light1.getMatrix().identity();
		pressedLeft = false;
		pressedMiddle = false;
		pressedRight = false;
	}

}

void processMotion(int x, int y)
{
	xf = (float)x/((float)window::width/2.0) - 1;
	yf = 1 - (float)y/((float)window::height/2.0);
	if (pressedLeft)
	{
		zf = findZ(xf,yf);
		Vector3 prev = Vector3(prevX,prevY,prevZ);
		Vector3 curr = Vector3(xf,yf,zf);
		
		Vector3 p = prev.normalize();
		Vector3 c = curr.normalize();
		prev.set(p.get(0), p.get(1), p.get(2));
		curr.set(c.get(0), c.get(1), c.get(2));

		theta = getTheta(prev, curr);
		Vector3 axis3 = prev.cross(prev, curr);
		Vector3 a = axis3.normalize();
		axis3.set(a.get(0), a.get(1), a.get(2));

		Vector4 axis4 = Vector4(axis3.get(0), axis3.get(1), axis3.get(2), 0);

		if (light0Toggle && light1Toggle) {
			temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().rotateAA(axis4,theta));
			temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().rotateAA(axis4,theta));
		}
		else if (light0Toggle) {
			temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().rotateAA(axis4,theta));
		}
		else if (light1Toggle) {
			temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().rotateAA(axis4,theta));
		}
		else {
			temp.getMatrix().setMatrix(*temp.getMatrix().rotateAA(axis4,theta));
		}
	}
	else if (pressedMiddle)
	{
		if (light0Toggle && light1Toggle) {
			temp_light0.getMatrix().identity();
			temp_light1.getMatrix().identity();
			temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().translate((xf-prevX)*15,(yf-prevY)*15,0));
			temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().translate((xf-prevX)*15,(yf-prevY)*15,0));
		}
		else if (light0Toggle) {
			temp_light0.getMatrix().identity();
			temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().translate((xf-prevX)*15,(yf-prevY)*15,0));
		}
		else if (light1Toggle) {
			temp_light1.getMatrix().identity();
			temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().translate((xf-prevX)*15,(yf-prevY)*15,0));
		}
		else {
			temp.getMatrix().identity();
			temp.getMatrix().setMatrix(*temp.getMatrix().translate((xf-prevX)*15,(yf-prevY)*15,0));
		}
	}
	else if (pressedRight)
	{
		float s;
		if (prevY < yf)
		{
			s = 1-(yf-prevY)*-2;
			if (light0Toggle && light1Toggle) {
				temp_light0.getMatrix().identity();
				temp_light1.getMatrix().identity();
				temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().scale(s,s,s));
				temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().scale(s,s,s));
			}
			else if (light0Toggle) {
				temp_light0.getMatrix().identity();
				temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().scale(s,s,s));
			}
			else if (light1Toggle) {
				temp_light1.getMatrix().identity();
				temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().scale(s,s,s));
			}
			else {
				temp.getMatrix().identity();
				temp.getMatrix().setMatrix(*temp.getMatrix().scale(s,s,s));
			}
		}
		else
		{
			float s = 1+(yf-prevY)*0.5;
			if (s < 0)
			{
				s = 0.0001;
			}
			if (light0Toggle && light1Toggle) {
				temp_light0.getMatrix().identity();
				temp_light1.getMatrix().identity();
				temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().scale(s,s,s));
				temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().scale(s,s,s));
			}
			else if (light0Toggle) {
				temp_light0.getMatrix().identity();
				temp_light0.getMatrix().setMatrix(*temp_light0.getMatrix().scale(s,s,s));
			}
			else if (light1Toggle) {
				temp_light1.getMatrix().identity();
				temp_light1.getMatrix().setMatrix(*temp_light1.getMatrix().scale(s,s,s));
			}
			else {
				temp.getMatrix().identity();
				temp.getMatrix().setMatrix(*temp.getMatrix().scale(s,s,s));
			}
		}
	}
}

void processNormalKeys(unsigned char key, int x, int y) {
	Vector3 v;
	switch (key)
	{
		// point light
		case '1':
			light0Toggle = !light0Toggle;
			cout << "Light 0 is: " << light0Toggle << endl;
			if (light0Toggle)
				glEnable(GL_LIGHT0);
			else
				glDisable(GL_LIGHT0);
			if (lightShaderToggle) {
				if (light0Toggle && light1Toggle) {
					shaderX->bind();
				}
				else if (light0Toggle) {
					shader0->bind();
				}
				else if (light1Toggle) {
					cout << "Binded shader 1" << endl;
					shader1->bind();
				}
			}
			else {
				if (light0Toggle && light1Toggle) {
					shaderX->unbind();
				}
				else if (light0Toggle) {
					shader0->unbind();
				}
				else if (light1Toggle) {
					shader1->unbind();
				}
			}
			if (!lightShaderToggle || light0Toggle) {
				cout << "should show" << endl;
				glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
				glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
			}
			else {
				glLightfv(GL_LIGHT0, GL_DIFFUSE, zero);
				glLightfv(GL_LIGHT0, GL_SPECULAR, zero);
			}
			break;
		// spot light
		case '2':
			light1Toggle = !light1Toggle;
			cout << "Light 1 is: " << light1Toggle << endl;
			if (light1Toggle)
				glEnable(GL_LIGHT1);
			else
				glDisable(GL_LIGHT1);
			if (lightShaderToggle) {
				if (light0Toggle && light1Toggle) {
					shaderX->bind();
				}
				else if (light0Toggle) {
					shader0->bind();
				}
				else if (light1Toggle) {
					cout << "Binded shader 1" << endl;
					shader1->bind();
				}
			}
			else {
				if (light0Toggle && light1Toggle) {
					shaderX->unbind();
				}
				else if (light0Toggle) {
					shader0->unbind();
				}
				else if (light1Toggle) {
					shader1->unbind();
				}
			}
			if (!lightShaderToggle || light1Toggle) {
				glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
				glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
			}
			else {
				glLightfv(GL_LIGHT1, GL_DIFFUSE, zero);
				glLightfv(GL_LIGHT1, GL_SPECULAR, zero);
			}
			break;
		case 'g':
			lightShaderToggle = !lightShaderToggle;
			cout << "Shaders on: " << lightShaderToggle << endl;
			if (lightShaderToggle) {
				if (light0Toggle && light1Toggle) {
					shaderX->bind();
				}
				else if (light0Toggle) {
					shader0->bind();
				}
				else if (light1Toggle) {
					cout << "Binded shader 1" << endl;
					shader1->bind();
				}
			}
			else {
				if (light0Toggle && light1Toggle) {
					shaderX->unbind();
				}
				else if (light0Toggle) {
					shader0->unbind();
				}
				else if (light1Toggle) {
					shader1->unbind();
				}
			}
			if (light0Toggle || light1Toggle) {
				glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
				glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
				glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
				glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
			}
			else {
				glLightfv(GL_LIGHT0, GL_DIFFUSE, zero);
				glLightfv(GL_LIGHT1, GL_DIFFUSE, zero);	
				glLightfv(GL_LIGHT0, GL_SPECULAR, zero);
				glLightfv(GL_LIGHT1, GL_SPECULAR, zero);
			}
			break;
		case 'r':
			base.getMatrix().identity();
			base_light0.getMatrix().identity();
			base_light1.getMatrix().identity();
			temp.getMatrix().identity();
			temp_light0.getMatrix().identity();
			temp_light1.getMatrix().identity();
			break;
		case 's':
			sphere = true;
			break;
		case 'd':
			sphere = false;
			break;
		case 'c':
			culling = true;
			break;
		case 'n':
			culling = false;
			break;
	}
}

void constructPlanes(Vector4 p[])
{
	Vector4 t4;
	Vector3 t3, v, u, n;
	// Near (ntl, ntr, nbl)
	v = t4.makeVector3Point(p[NTR])-t4.makeVector3Point(p[NTL]);
	u = t4.makeVector3Point(p[NBL])-t4.makeVector3Point(p[NTL]);
	n = t3.cross(v,u);
	frustum[0][0] = n[0]/n.magnitude();
	frustum[0][1] = n[1]/n.magnitude();
	frustum[0][2] = n[2]/n.magnitude();
	frustum[0][3] = (n.negate()).dot(t4.makeVector3Point(p[NTR]))/n.magnitude();

	// Far (ftl, ftr, fbl)
	v = t4.makeVector3Point(p[FTR])-t4.makeVector3Point(p[FTL]);
	u = t4.makeVector3Point(p[FBL])-t4.makeVector3Point(p[FTL]);
	n = t3.cross(v,u);
	frustum[1][0] = n[0]/n.magnitude();
	frustum[1][1] = n[1]/n.magnitude();
	frustum[1][2] = n[2]/n.magnitude();
	frustum[1][3] = (n.negate()).dot(t4.makeVector3Point(p[FTL]))/n.magnitude();

	// Left (ntl, ftl, nbl)
	v = t4.makeVector3Point(p[FTL])-t4.makeVector3Point(p[NTL]);
	u = t4.makeVector3Point(p[NBL])-t4.makeVector3Point(p[NTL]);
	n = t3.cross(v,u);
	frustum[2][0] = n[0]/n.magnitude();
	frustum[2][1] = n[1]/n.magnitude();
	frustum[2][2] = n[2]/n.magnitude();
	frustum[2][3] = (n.negate()).dot(t4.makeVector3Point(p[NTL]))/n.magnitude();

	// Right (ntr, ftr, fbr)
	v = t4.makeVector3Point(p[FTR])-t4.makeVector3Point(p[NTR]);
	u = t4.makeVector3Point(p[FBR])-t4.makeVector3Point(p[NTR]);
	n = t3.cross(v,u);
	frustum[3][0] = n[0]/n.magnitude();
	frustum[3][1] = n[1]/n.magnitude();
	frustum[3][2] = n[2]/n.magnitude();
	frustum[3][3] = (n.negate()).dot(t4.makeVector3Point(p[NTR]))/n.magnitude();

	// Top (ntl, ftl, ftr)
	v = t4.makeVector3Point(p[FTL])-t4.makeVector3Point(p[NTL]);
	u = t4.makeVector3Point(p[FTR])-t4.makeVector3Point(p[NTL]);
	n = t3.cross(v,u);
	frustum[4][0] = n[0]/n.magnitude();
	frustum[4][1] = n[1]/n.magnitude();
	frustum[4][2] = n[2]/n.magnitude();
	frustum[4][3] = (n.negate()).dot(t4.makeVector3Point(p[NTL]))/n.magnitude();

	// Bottom (nbl, fbl, fbr)
	v = t4.makeVector3Point(p[FBL])-t4.makeVector3Point(p[NBL]);
	u = t4.makeVector3Point(p[FBR])-t4.makeVector3Point(p[NBL]);
	n = t3.cross(v,u);
	frustum[5][0] = n[0]/n.magnitude();
	frustum[5][1] = n[1]/n.magnitude();
	frustum[5][2] = n[2]/n.magnitude();
	frustum[5][3] = (n.negate()).dot(t4.makeVector3Point(p[NBL]))/n.magnitude();

}

void setDefaultFrustum()
{
	/*fc = p + d * farDist

	ftl = fc + (up * Hfar/2) - (right * Wfar/2)
	ftr = fc + (up * Hfar/2) + (right * Wfar/2)
	fbl = fc - (up * Hfar/2) - (right * Wfar/2)
	fbr = fc - (up * Hfar/2) + (right * Wfar/2)

	nc = p + d * nearDist 

	ntl = nc + (up * Hnear/2) - (right * Wnear/2)
	ntr = nc + (up * Hnear/2) + (right * Wnear/2)
	nbl = nc - (up * Hnear/2) - (right * Wnear/2)
	nbr = nc - (up * Hnear/2) + (right * Wnear/2)*/

	// may be wrong
	Vector3 right = up.cross(up,d);
	Vector3 fc = p+(d.scale(zFar));
	Vector3 v;

	v = fc+(up.scale(vf_hfar/2))-(right.scale(vf_wfar/2));
	Vector4 ftl = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = fc+(up.scale(vf_hfar/2))+(right.scale(vf_wfar/2));
	Vector4 ftr = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = fc-(up.scale(vf_hfar/2))-(right.scale(vf_wfar/2));
	Vector4 fbl = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = fc-(up.scale(vf_hfar/2))+(right.scale(vf_wfar/2));
	Vector4 fbr = Vector4(v.get(0), v.get(1), v.get(2), 1);

	Vector3 nc = p+(d.scale(zNear));
	v = nc+(up.scale(vf_hnear/2))-(right.scale(vf_wnear/2));
	Vector4 ntl = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = nc+(up.scale(vf_hnear/2))+(right.scale(vf_wnear/2));
	Vector4 ntr = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = nc-(up.scale(vf_hnear/2))-(right.scale(vf_wnear/2));
	Vector4 nbl = Vector4(v.get(0), v.get(1), v.get(2), 1);
	v = nc-(up.scale(vf_hnear/2))+(right.scale(vf_wnear/2));
	Vector4 nbr = Vector4(v.get(0), v.get(1), v.get(2), 1);

	frustum_points[FTL] = ftl;
	frustum_points[FTR] = ftr;
	frustum_points[FBL] = fbl;
	frustum_points[FBR] = fbr;
	frustum_points[NTL] = ntl;
	frustum_points[NTR] = ntr;
	frustum_points[NBL] = nbl;
	frustum_points[NBR] = nbr;

	for (int i=0; i<8; i++)
	{
		frustum_points[i].print();
	}

	constructPlanes(frustum_points);
}

void recalculateFrustum(Matrix4 m)
{
	Vector4 v;
	for (int i=0; i<8; i++)
	{
		frustum_points[i] = *m.multiply(frustum_points[i]);
	}
	constructPlanes(frustum_points);
}

void ExtractFrustum(Matrix4 m)
{
	float proj[16];
	float modl[16];
	float clip[16];
	float t;
	/* Get the current PROJECTION matrix from OpenGL */
	glGetFloatv( GL_PROJECTION_MATRIX, proj );
	/* Get the current MODELVIEW matrix from OpenGL */
	//glGetFloatv( GL_MODELVIEW_MATRIX, modl );
	for (int i=0; i<16; i++) {
		modl[i] = *(m.getPointer()+i);
	}
	/* Combine the two matrices (multiply projection by modelview)    */
	clip[ 0] = modl[ 0] * proj[ 0] + modl[ 1] * proj[ 4] + modl[ 2] * proj[ 8] +    modl[ 3] * proj[12];
	clip[ 1] = modl[ 0] * proj[ 1] + modl[ 1] * proj[ 5] + modl[ 2] * proj[ 9] +    modl[ 3] * proj[13];
	clip[ 2] = modl[ 0] * proj[ 2] + modl[ 1] * proj[ 6] + modl[ 2] * proj[10] +    modl[ 3] * proj[14];
	clip[ 3] = modl[ 0] * proj[ 3] + modl[ 1] * proj[ 7] + modl[ 2] * proj[11] +    modl[ 3] * proj[15];
	clip[ 4] = modl[ 4] * proj[ 0] + modl[ 5] * proj[ 4] + modl[ 6] * proj[ 8] +    modl[ 7] * proj[12];
	clip[ 5] = modl[ 4] * proj[ 1] + modl[ 5] * proj[ 5] + modl[ 6] * proj[ 9] +    modl[ 7] * proj[13];
	clip[ 6] = modl[ 4] * proj[ 2] + modl[ 5] * proj[ 6] + modl[ 6] * proj[10] +    modl[ 7] * proj[14];
	clip[ 7] = modl[ 4] * proj[ 3] + modl[ 5] * proj[ 7] + modl[ 6] * proj[11] +    modl[ 7] * proj[15];
	clip[ 8] = modl[ 8] * proj[ 0] + modl[ 9] * proj[ 4] + modl[10] * proj[ 8] +    modl[11] * proj[12];
	clip[ 9] = modl[ 8] * proj[ 1] + modl[ 9] * proj[ 5] + modl[10] * proj[ 9] +    modl[11] * proj[13];
	clip[10] = modl[ 8] * proj[ 2] + modl[ 9] * proj[ 6] + modl[10] * proj[10] +    modl[11] * proj[14];
	clip[11] = modl[ 8] * proj[ 3] + modl[ 9] * proj[ 7] + modl[10] * proj[11] +    modl[11] * proj[15];
	clip[12] = modl[12] * proj[ 0] + modl[13] * proj[ 4] + modl[14] * proj[ 8] +    modl[15] * proj[12];
	clip[13] = modl[12] * proj[ 1] + modl[13] * proj[ 5] + modl[14] * proj[ 9] +    modl[15] * proj[13];
	clip[14] = modl[12] * proj[ 2] + modl[13] * proj[ 6] + modl[14] * proj[10] +    modl[15] * proj[14];
	clip[15] = modl[12] * proj[ 3] + modl[13] * proj[ 7] + modl[14] * proj[11] +    modl[15] * proj[15];
	/* Extract the numbers for the RIGHT plane */
	frustum[0][0] = clip[ 3] - clip[ 0];
	frustum[0][1] = clip[ 7] - clip[ 4];
	frustum[0][2] = clip[11] - clip[ 8];
	frustum[0][3] = clip[15] - clip[12];
	/* Normalize the result */
	t = sqrt( frustum[0][0] * frustum[0][0] + frustum[0][1] * frustum[0][1] + frustum[0][2]    * frustum[0][2] );
	frustum[0][0] /= t;
	frustum[0][1] /= t;
	frustum[0][2] /= t;
	frustum[0][3] /= t;
	/* Extract the numbers for the LEFT plane */
	frustum[1][0] = clip[ 3] + clip[ 0];
	frustum[1][1] = clip[ 7] + clip[ 4];
	frustum[1][2] = clip[11] + clip[ 8];
	frustum[1][3] = clip[15] + clip[12];
	/* Normalize the result */
	t = sqrt( frustum[1][0] * frustum[1][0] + frustum[1][1] * frustum[1][1] + frustum[1][2]    * frustum[1][2] );
	frustum[1][0] /= t;
	frustum[1][1] /= t;
	frustum[1][2] /= t;
	frustum[1][3] /= t;
	/* Extract the BOTTOM plane */
	frustum[2][0] = clip[ 3] + clip[ 1];
	frustum[2][1] = clip[ 7] + clip[ 5];
	frustum[2][2] = clip[11] + clip[ 9];
	frustum[2][3] = clip[15] + clip[13];
	/* Normalize the result */
	t = sqrt( frustum[2][0] * frustum[2][0] + frustum[2][1] * frustum[2][1] + frustum[2][2]    * frustum[2][2] );
	frustum[2][0] /= t;
	frustum[2][1] /= t;
	frustum[2][2] /= t;
	frustum[2][3] /= t;
	/* Extract the TOP plane */
	frustum[3][0] = clip[ 3] - clip[ 1];
	frustum[3][1] = clip[ 7] - clip[ 5];
	frustum[3][2] = clip[11] - clip[ 9];
	frustum[3][3] = clip[15] - clip[13];
	/* Normalize the result */
	t = sqrt( frustum[3][0] * frustum[3][0] + frustum[3][1] * frustum[3][1] + frustum[3][2]    * frustum[3][2] );
	frustum[3][0] /= t;
	frustum[3][1] /= t;
	frustum[3][2] /= t;
	frustum[3][3] /= t;
	/* Extract the FAR plane */
	frustum[4][0] = clip[ 3] - clip[ 2];
	frustum[4][1] = clip[ 7] - clip[ 6];
	frustum[4][2] = clip[11] - clip[10];
	frustum[4][3] = clip[15] - clip[14];
	/* Normalize the result */
	t = sqrt( frustum[4][0] * frustum[4][0] + frustum[4][1] * frustum[4][1] + frustum[4][2]    * frustum[4][2] );
	frustum[4][0] /= t;
	frustum[4][1] /= t;
	frustum[4][2] /= t;
	frustum[4][3] /= t;
	/* Extract the NEAR plane */
	frustum[5][0] = clip[ 3] + clip[ 2];
	frustum[5][1] = clip[ 7] + clip[ 6];
	frustum[5][2] = clip[11] + clip[10];
	frustum[5][3] = clip[15] + clip[14];
	/* Normalize the result */
	t = sqrt( frustum[5][0] * frustum[5][0] + frustum[5][1] * frustum[5][1] + frustum[5][2]    * frustum[5][2] );
	frustum[5][0] /= t;
	frustum[5][1] /= t;
	frustum[5][2] /= t;
	frustum[5][3] /= t;
}

//----------------------------------------------------------------------------
// Callback method called when system is idle.
void window::idleCallback(void)
{
	displayCallback();    // call display routine to redraw cube
	calculateFPS();
}

//----------------------------------------------------------------------------
// Callback method called when window is resized.
void window::reshapeCallback(int w, int h)
{	
	width = w;
	height = h;
	glViewport(0, 0, w, h);  // set new viewport size
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(fovy,aspect,zNear,zFar);
}

//----------------------------------------------------------------------------
// Callback method called when window readraw is necessary or
// when glutPostRedisplay() was called.
void window::displayCallback(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // clear color and depth buffers

	world.getMatrix().setMatrix(*base.getMatrix().multiply(temp.getMatrix()));
	camera.inverseCamera();
	
	all.getMatrix().setMatrix(world.getMatrix());
	all.getMatrix().setMatrix(*all.getMatrix().multiply(camera.getMatrix()));

	if (debug)
	{
		glColor3d(1.0,0.0,0.0);
		glutSolidSphere(.25,10,10);
	}

	recalculateFrustum(all.getMatrix());
	//drawFrustum();
	
	g_world->draw(all.getMatrix());

	drawFPS();
	//cout << fps << endl;

	glutSwapBuffers();
}



int main(int argc, char *argv[])
{
	GLfloat ambient[]         = {0.5,0.5,0.5,1.0};				// default ambient color for all light sources

	glutInit(&argc, argv);											// initialize GLUT
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);		// open an OpenGL context with double buffering, RGB colors, and depth buffering
	glutInitWindowSize(512, 512);									// set initial window size
	glutCreateWindow("Scene Graph");								// open window and set window title

	glEnable(GL_DEPTH_TEST);										// enable z-buffer
	glClearColor(0.0, 0.0, 0.0, 0.0);								// set clear color to black

	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient);				// set the default ambient color
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);		// allow glColor to set ambient and diffuse colors of geometry

	// Generate light source:
	//glEnable(GL_LIGHTING);											// enables lighting; this changes the behavior of glColor
	glDisable(GL_LIGHTING);
	//glDisable(GL_LIGHT0);											// enable a light source; otherwise you will only see ambient light
	glEnable(GL_LIGHT0);
	//glDisable(GL_LIGHT1);											// enable a light source; otherwise you will only see ambient light
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	/*glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
	glLightfv(GL_LIGHT0, GL_SHININESS, light0_shininess);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
	glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
	glLightfv(GL_LIGHT1, GL_SHININESS, light1_shininess);
	glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, light1_direction);
	glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
	glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, 10.0);
	glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, 0.0);*/
	
	// Install callback functions:
	glutDisplayFunc(window::displayCallback);
	glutReshapeFunc(window::reshapeCallback);
	glutIdleFunc(window::idleCallback);

	glutMouseFunc(processMouse);
	glutMotionFunc(processMotion);
	glutKeyboardFunc(processNormalKeys);
  
	//glEnable(GL_NORMALIZE);
	//glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);

	// Initialize cube matrix:
	m_id.identity();
	all.getMatrix().identity();
	cube1.getMatrix().identity();
	cube2.getMatrix().identity();
	dragon.getMatrix().identity();
	base.getMatrix().identity();
	temp.getMatrix().identity();
	world.getMatrix().identity();
	base_light0.getMatrix().identity();
	temp_light0.getMatrix().identity();
	world_light0.getMatrix().identity();
	base_light1.getMatrix().identity();
	temp_light1.getMatrix().identity();
	world_light1.getMatrix().identity();
	light0.getMatrix().identity();
	light1.getMatrix().identity();

	// Shaders
	/*shader0 = new Shader(light0_vert,light0_frag,true);
	shader1 = new Shader(light1_vert,light1_frag,true);
	shaderX = new Shader(lightX_vert,lightX_frag,true);*/

	/*cout << "Loading dragon_smooth.obj" << endl;
	objReader.readObj("dragon_smooth.obj", nVerts, &vertices, &normals, &texcoords, nIndices, &indices);*/

	camera.lookAt(p,d,up);
	createWorld();

	vf_hnear = 2*tan(fovy/2)*zNear;
	vf_wnear = vf_hnear*aspect;
	vf_hfar = 2*tan(fovy/2)*zFar;
	vf_wfar = vf_hfar*aspect;
	setDefaultFrustum();

	glutMainLoop();
	return 0;
}

